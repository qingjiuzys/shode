#!/usr/bin/env shode
# CLI å·¥å…·ç¤ºä¾‹ - åŠŸèƒ½å®Œæ•´çš„å‘½ä»¤è¡Œåº”ç”¨
# æ¼”ç¤º Shode æ¡†æ¶åœ¨ CLI åº”ç”¨ä¸­çš„èƒ½åŠ›

import {
    cli,
    fs,
    logger,
    config,
    terminal
} from "std"

// ç‰ˆæœ¬ä¿¡æ¯
VERSION = "1.0.0"

// åˆå§‹åŒ–æ—¥å¿—
log = logger.new({
    level: "info",
    format: "text",
    colorize: true
})

// åŠ è½½é…ç½®
cfg = config.load("config/default.conf")

// === CLI åº”ç”¨å®šä¹‰ ===

app = cli.app({
    name: "shode-cli",
    version: VERSION,
    description: "Shode CLI - å¼ºå¤§çš„å‘½ä»¤è¡Œå·¥å…·",
    author: "Shode Team",
    enable_completion: true
})

// === å…¨å±€é€‰é¡¹ ===

app.option("verbose", "v", "è¯¦ç»†è¾“å‡º", false)
app.option("quiet", "q", "é™é»˜æ¨¡å¼", false)
app.option("config", "c", "é…ç½®æ–‡ä»¶è·¯å¾„", "")
app.option("format", "f", "è¾“å‡ºæ ¼å¼ (text, json, table)", "text")

// === å‘½ä»¤ï¼šinit - åˆå§‹åŒ–é¡¹ç›® ===

app.command("init", "åˆå§‹åŒ–æ–°é¡¹ç›®", func(args, options) {
    // æ£€æŸ¥å‚æ•°
    if len(args) == 0 {
        log.error("è¯·æŒ‡å®šé¡¹ç›®åç§°")
        print("ç”¨æ³•: shode-cli init <project-name> [options]")
        return
    }

    project_name = args[0]

    // è§£æé€‰é¡¹
    template = options.template || "default"
    description = options.description || ""
    author = options.author || ""
    git_init = options.git || false

    // æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
    if fs.exists(project_name) {
        log.error("ç›®å½• ${project_name} å·²å­˜åœ¨")
        return
    }

    // æ˜¾ç¤ºåˆå§‹åŒ–ä¿¡æ¯
    terminal.print_header("ğŸš€ åˆå§‹åŒ–é¡¹ç›®")

    print("é¡¹ç›®åç§°: ${project_name}")
    print("æ¨¡æ¿: ${template}")
    print("")

    // åˆ›å»ºé¡¹ç›®ç›®å½•
    terminal.spinner("åˆ›å»ºé¡¹ç›®ç›®å½•...", func() {
        fs.mkdir(project_name)
        fs.mkdir("${project_name}/src")
        fs.mkdir("${project_name}/tests")
        fs.mkdir("${project_name}/config")
        fs.mkdir("${project_name}/docs")
    })

    // åˆ›å»ºä¸»æ–‡ä»¶
    terminal.spinner("åˆ›å»ºä¸»æ–‡ä»¶...", func() {
        main_content = """# ${project_name}

import { http, server } from "std"

server.get("/", func(req, res) {
    res.json({
        message: "Hello from ${project_name}!"
    })
})

server.listen(8080)
"""
        fs.write("${project_name}/main.shode", main_content)
    })

    // åˆ›å»ºé…ç½®æ–‡ä»¶
    terminal.spinner("åˆ›å»ºé…ç½®æ–‡ä»¶...", func() {
        config_content = """# ${project_name} é…ç½®

server {
    port: 8080
    host: "0.0.0.0"
}

logging {
    level: "info"
}
"""
        fs.write("${project_name}/config/app.shode", config_content)
    })

    // åˆ›å»º README
    terminal.spinner("åˆ›å»º README...", func() {
        readme_content = """# ${project_name}

${description}

## å¿«é€Ÿå¼€å§‹

\`\`\`bash
shode run main.shode
\`\`\`

## é¡¹ç›®ç»“æ„

\`\`\`
.
â”œâ”€â”€ main.shode    # ä¸»ç¨‹åº
â”œâ”€â”€ src/          # æºä»£ç 
â”œâ”€â”€ tests/        # æµ‹è¯•
â”œâ”€â”€ config/       # é…ç½®
â””â”€â”€ docs/         # æ–‡æ¡£
\`\`\`
"""
        fs.write("${project_name}/README.md", readme_content)
    })

    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
    terminal.spinner("åˆ›å»ºæµ‹è¯•æ–‡ä»¶...", func() {
        test_content = """# æµ‹è¯•

import { assert, assertEquals } from "testing"

test("example test", func() {
    result = 1 + 1
    assertEquals(result, 2)
})
"""
        fs.write("${project_name}/tests/main_test.shode", test_content)
    })

    // åˆå§‹åŒ– Git
    if git_init {
        terminal.spinner("åˆå§‹åŒ– Git ä»“åº“...", func() {
            exec("git init ${project_name}")
            fs.write("${project_name}/.gitignore", """# Shode
*.shodec
node_modules/
dist/

# OS
.DS_Store
Thumbs.db
""")
        })
    }

    // å®Œæˆ
    terminal.print_success("âœ“ é¡¹ç›® ${project_name} åˆ›å»ºæˆåŠŸï¼")
    print("")
    print("ä¸‹ä¸€æ­¥:")
    print("  cd ${project_name}")
    print("  shode run main.shode")
    print("")
})

// init å‘½ä»¤é€‰é¡¹
app.command("init").option("template", "t", "æ¨¡æ¿åç§°", "default")
app.command("init").option("description", "d", "é¡¹ç›®æè¿°", "")
app.command("init").option("author", "a", "ä½œè€…åç§°", "")
app.command("init").option("git", "g", "åˆå§‹åŒ– Git", false)

// === å‘½ä»¤ï¼šbuild - æ„å»ºé¡¹ç›® ===

app.command("build", "æ„å»ºé¡¹ç›®", func(args, options) {
    output_dir = options.output || "dist"
    minify = options.minify || false
    watch = options.watch || false

    terminal.print_header("ğŸ”¨ æ„å»ºé¡¹ç›®")

    // æ£€æŸ¥é¡¹ç›®æ–‡ä»¶
    if !fs.exists("main.shode") {
        log.error("æœªæ‰¾åˆ° main.shode æ–‡ä»¶")
        return
    }

    // åˆ›å»ºè¾“å‡ºç›®å½•
    fs.mkdir(output_dir)

    // æ„å»ºæ­¥éª¤
    steps = [
        {name: "è§£æä»£ç ", fn: func() { /* è§£æ AST */ }},
        {name: "ç±»å‹æ£€æŸ¥", fn: func() { /* ç±»å‹æ£€æŸ¥ */ }},
        {name: "ç¼–è¯‘å­—èŠ‚ç ", fn: func() { /* ç¼–è¯‘ */ }},
        {name: "ä¼˜åŒ–ä»£ç ", fn: func() { /* ä¼˜åŒ– */ }},
        {name: "ç”Ÿæˆè¾“å‡º", fn: func() {
            fs.write("${output_dir}/app.shodec", "compiled code")
        }}
    ]

    // æ‰§è¡Œæ„å»ºæ­¥éª¤
    for step in steps {
        terminal.spinner("${step.name}...", step.fn)
    }

    // æ˜¾ç¤ºç»“æœ
    terminal.print_success("âœ“ æ„å»ºå®Œæˆï¼")
    print("è¾“å‡ºç›®å½•: ${output_dir}")
    print("æ–‡ä»¶å¤§å°: ${fs.size("${output_dir}/app.shodec")} bytes")

    // ç›‘å¬æ¨¡å¼
    if watch {
        print("\nğŸ‘€ ç›‘å¬æ–‡ä»¶å˜åŒ–...")
        fs.watch(".", func(events) {
            for event in events {
                if event.path.endswith(".shode") {
                    print("\nğŸ“ ${event.path} å·²æ›´æ”¹ï¼Œé‡æ–°æ„å»º...")
                    app.run(["build"])
                }
            }
        })
    }
})

app.command("build").option("output", "o", "è¾“å‡ºç›®å½•", "dist")
app.command("build").option("minify", "m", "å‹ç¼©è¾“å‡º", false)
app.command("build").option("watch", "w", "ç›‘å¬æ¨¡å¼", false)

// === å‘½ä»¤ï¼šdeploy - éƒ¨ç½²é¡¹ç›® ===

app.command("deploy", "éƒ¨ç½²é¡¹ç›®", func(args, options) {
    env = options.env || "development"
    config_file = options.config || "config/deploy.shode"
    dry_run = options.dry_run || false

    terminal.print_header("ğŸš€ éƒ¨ç½²é¡¹ç›®")

    // åŠ è½½éƒ¨ç½²é…ç½®
    if fs.exists(config_file) {
        deploy_config = config.load(config_file)
    } else {
        log.warn("æœªæ‰¾åˆ°éƒ¨ç½²é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤é…ç½®")
        deploy_config = {
            provider: "docker",
            registry: "localhost:5000",
            namespace: "shode"
        }
    }

    // æ˜¾ç¤ºéƒ¨ç½²ä¿¡æ¯
    print("ç¯å¢ƒ: ${env}")
    print("æä¾›å•†: ${deploy_config.provider}")
    print("é•œåƒ: ${deploy_config.registry}/${deploy_config.namespace}/app:${env}")
    print("")

    if dry_run {
        print("âš ï¸  æ¨¡æ‹Ÿè¿è¡Œæ¨¡å¼")
    }

    // éƒ¨ç½²æ­¥éª¤
    steps = [
        {name: "æ„å»ºé•œåƒ", fn: func() {
            if !dry_run {
                exec("docker build -t app:${env} .")
            }
        }},
        {name: "æ ‡è®°é•œåƒ", fn: func() {
            if !dry_run {
                exec("docker tag app:${env} ${deploy_config.registry}/${deploy_config.namespace}/app:${env}")
            }
        }},
        {name: "æ¨é€é•œåƒ", fn: func() {
            if !dry_run {
                exec("docker push ${deploy_config.registry}/${deploy_config.namespace}/app:${env}")
            }
        }},
        {name: "éƒ¨ç½²åº”ç”¨", fn: func() {
            if !dry_run {
                exec("kubectl set image deployment/app app=${deploy_config.registry}/${deploy_config.namespace}/app:${env}")
            }
        }}
    ]

    // æ‰§è¡Œéƒ¨ç½²
    for step in steps {
        terminal.spinner("${step.name}...", step.fn)
    }

    terminal.print_success("âœ“ éƒ¨ç½²å®Œæˆï¼")
})

app.command("deploy").option("env", "e", "éƒ¨ç½²ç¯å¢ƒ", "development")
app.command("deploy").option("config", "c", "é…ç½®æ–‡ä»¶", "")
app.command("deploy").option("dry-run", "d", "æ¨¡æ‹Ÿè¿è¡Œ", false)

// === å‘½ä»¤ï¼štest - è¿è¡Œæµ‹è¯• ===

app.command("test", "è¿è¡Œæµ‹è¯•", func(args, options) {
    verbose = options.verbose || false
    cover = options.cover || false
    filter = options.filter || ""

    terminal.print_header("ğŸ§ª è¿è¡Œæµ‹è¯•")

    // æŸ¥æ‰¾æµ‹è¯•æ–‡ä»¶
    test_files = fs.glob("tests/**/*_test.shode")

    if len(test_files) == 0 {
        log.warn("æœªæ‰¾åˆ°æµ‹è¯•æ–‡ä»¶")
        return
    }

    print("æ‰¾åˆ° ${len(test_files)} ä¸ªæµ‹è¯•æ–‡ä»¶")
    print("")

    // ç»Ÿè®¡
    total_tests = 0
    passed_tests = 0
    failed_tests = 0

    // è¿è¡Œæµ‹è¯•
    for test_file in test_files {
        print("è¿è¡Œ: ${test_file}")

        // åŠ è½½å¹¶è¿è¡Œæµ‹è¯•
        test_module = require(test_file)

        for test_name in test_module.tests {
            if filter != "" && !test_name.contains(filter) {
                continue
            }

            total_tests++

            try {
                test_module.tests[test_name]()
                if verbose {
                    terminal.print_checkmark("  âœ“ ${test_name}")
                }
                passed_tests++
            } catch e {
                terminal.print_xmark("  âœ— ${test_name}")
                if verbose {
                    print("    é”™è¯¯: ${e.message}")
                }
                failed_tests++
            }
        }
    }

    // æ˜¾ç¤ºç»“æœ
    print("")
    terminal.print_header("æµ‹è¯•ç»“æœ")
    print("æ€»è®¡: ${total_tests}")
    terminal.print_success("é€šè¿‡: ${passed_tests}")
    if failed_tests > 0 {
        terminal.print_error("å¤±è´¥: ${failed_tests}")
    }

    if cover {
        // æ˜¾ç¤ºè¦†ç›–ç‡
        coverage = calculate_coverage()
        print("\nè¦†ç›–ç‡: ${coverage}%")
    }

    // è¿”å›é€€å‡ºç 
    if failed_tests > 0 {
        exit(1)
    }
})

app.command("test").option("verbose", "v", "è¯¦ç»†è¾“å‡º", false)
app.command("test").option("cover", "c", "æ˜¾ç¤ºè¦†ç›–ç‡", false)
app.command("test").option("filter", "f", "è¿‡æ»¤æµ‹è¯•", "")

// === å‘½ä»¤ï¼šlist - åˆ—å‡ºèµ„æº ===

app.command("list", "åˆ—å‡ºèµ„æº", func(args, options) {
    resource_type = args[0] || "all"
    format = options.format || "table"

    // æ•°æ®
    resources = [
        {name: "my-project", status: "running", version: "1.0.0", created: "2026-01-15"},
        {name: "api-service", status: "stopped", version: "2.1.0", created: "2026-01-14"},
        {name: "web-app", status: "running", version: "1.5.2", created: "2026-01-13"}
    ]

    // æ ¼å¼åŒ–è¾“å‡º
    if format == "table" {
        terminal.table({
            headers: ["NAME", "STATUS", "VERSION", "CREATED"],
            rows: resources.map(func(r) {
                return [r.name, r.status, r.version, r.created]
            })
        })
    } else if format == "json" {
        print(json.stringify(resources, true, 2))
    } else {
        for r in resources {
            print("${r.name}\t${r.status}\t${r.version}\t${r.created}")
        }
    }
})

app.command("list").option("format", "f", "è¾“å‡ºæ ¼å¼", "table")

// === å‘½ä»¤ï¼šversion - æ˜¾ç¤ºç‰ˆæœ¬ ===

app.command("version", "æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯", func(args, options) {
    print("Shode CLI v${VERSION}")
    print("")
    print("æ„å»ºä¿¡æ¯:")
    print("  Goç‰ˆæœ¬: ${runtime.go_version()}")
    print("  å¹³å°: ${runtime.os()}/${runtime.arch()}")
    print("  ç¼–è¯‘æ—¶é—´: ${BUILD_TIME || 'unknown'}")
})

// === å‘½ä»¤ï¼šcompletion - ç”Ÿæˆè‡ªåŠ¨è¡¥å…¨è„šæœ¬ ===

app.command("completion", "ç”Ÿæˆè‡ªåŠ¨è¡¥å…¨è„šæœ¬", func(args, options) {
    shell = args[0] || "bash"

    if shell == "bash" {
        print("""# Bash completion for shode-cli
_shode_cli_completion() {
    local cur prev commands
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    commands="init build deploy test list version completion"

    if [[ ${COMP_CWORD} -eq 1 ]] ; then
        COMPREPLY=( $(compgen -W "${commands}" -- ${cur}) )
        return 0
    fi

    case "${prev}" in
        init)
            COMPREPLY=( $(compgen -f -- ${cur}) )
            ;;
        build|deploy|test)
            COMPREPLY=( $(compgen -W "--help --verbose --quiet" -- ${cur}) )
            ;;
        *)
            ;;
    esac
}

complete -F _shode_cli_completion shode-cli""")
    } else if shell == "zsh" {
        print("""#compdef shode-cli

_shode-cli() {
    local -a commands
    commands=(
        'init:Initialize a new project'
        'build:Build the project'
        'deploy:Deploy the project'
        'test:Run tests'
        'list:List resources'
        'version:Show version'
        'completion:Generate completion script'
    )

    if (( CURRENT == 2 )); then
        _describe 'command' commands
    elif (( CURRENT == 3 )); then
        case ${words[2]} in
            init)
                _files
                ;;
            *)
                _arguments \
                    '--verbose[Verbose output]' \
                    '--quiet[Quiet mode]' \
                    '--config[Config file]'
                ;;
        esac
    fi
}

_shode-cli "$@" """)
    } else {
        log.error("ä¸æ”¯æŒçš„ shell: ${shell}")
        print("æ”¯æŒçš„ shell: bash, zsh")
        exit(1)
    }
})

// === è¿è¡Œåº”ç”¨ ===

try {
    app.run()
} catch e {
    log.error("é”™è¯¯: ${e.message}")
    if options.verbose {
        print(e.stack)
    }
    exit(1)
}
